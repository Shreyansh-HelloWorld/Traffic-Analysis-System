# -*- coding: utf-8 -*-
"""ANPR_VIDEO_TESTING (3).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b8FjMvmJxAkz0AjM7wGDBFzpdmgg4jsR
"""

!nvidia-smi

# from google.colab import files
# files.upload()

# !unzip ANPR_DEMO.zip

!pip install -q ultralytics opencv-python
!pip uninstall -y paddleocr paddlepaddle paddlex
!pip install paddleocr==2.7.3 paddlepaddle==2.6.2 "numpy<2.0.0"

import paddle
import paddleocr
import numpy as np

print("Paddle version:", paddle.__version__)
print("NumPy version:", np.__version__)

import os
os.environ["FLAGS_use_cuda"] = "0"

import cv2
import os
import csv
import re
from ultralytics import YOLO
from paddleocr import PaddleOCR

# VIDEO_PATH = "/content/Test0.mp4"
# VIDEO_PATH = "/content/Test1.mp4"
VIDEO_PATH = "/content/Test2.mp4"
# VIDEO_PATH = "/content/Test3.mp4"
# VIDEO_PATH = "/content/Test4.mp4"
# VIDEO_PATH = "/content/Test5.mp4"
# VIDEO_PATH = "/content/Test6.mp4"
# VIDEO_PATH = "/content/Test7.mp4"
# VIDEO_PATH = "/content/Test8.mp4"
# VIDEO_PATH = "/content/Test9.mp4"
# VIDEO_PATH = "/content/Test10.mp4"


# YOLO_WEIGHTS = "/content/best.pt"
YOLO_WEIGHTS = "/content/best_2.pt"

OUTPUT_VIDEO = "/content/output_anpr (10).mp4"
OUTPUT_CSV = "/content/anpr_results (10).csv"

import os

print(os.path.exists(YOLO_WEIGHTS))
print(os.path.exists(VIDEO_PATH))

yolo_model = YOLO(YOLO_WEIGHTS)

from paddleocr import PaddleOCR

ocr = PaddleOCR(
    use_angle_cls=True,
    lang="en",
    det=False,
    rec=True,
    show_log=False,
    use_gpu=False
)

import paddle
print("Paddle version:", paddle.__version__)
print("CUDA available to Paddle:", paddle.device.is_compiled_with_cuda())

STATE_CODES = {
    "AN","AP","AR","AS","BR","CH","CG","DD","DL","DN",
    "GA","GJ","HR","HP","JH","JK","KA","KL","LD","MH",
    "ML","MN","MP","MZ","NL","OD","PB","PY","RJ","SK",
    "TN","TR","TS","UK","UP","WB"
}

def clean_plate(text):
    text = text.upper()
    return re.sub(r'[^A-Z0-9]', '', text)

def smart_post(raw):
    if not raw:
        return "UNREADABLE"

    raw = clean_plate(raw)

    # find valid state code
    for i in range(len(raw)-1):
        if raw[i:i+2] in STATE_CODES:
            raw = raw[i:]
            break

    if len(raw) < 6 or raw[:2] not in STATE_CODES:
        return "INVALID"

    state = raw[:2]
    rest = list(raw[2:])

    for i in range(len(rest)):
        if i < 2:
            rest[i] = rest[i].replace('O','0').replace('I','1')
        elif i >= len(rest)-4:
            rest[i] = rest[i].replace('O','0').replace('I','1').replace('S','5').replace('B','8')

    plate = state + ''.join(rest)

    if re.match(r'^[A-Z]{2}[0-9]{1,2}[A-Z]{1,3}[0-9]{4}$', plate):
        return plate

    return "INVALID"

import os

FRAME_SAVE_DIR = "detected_frames"
os.makedirs(FRAME_SAVE_DIR, exist_ok=True)

cap = cv2.VideoCapture(VIDEO_PATH)
import csv
saved_plates = set()

w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = cap.get(cv2.CAP_PROP_FPS)

out = cv2.VideoWriter(
    OUTPUT_VIDEO,
    cv2.VideoWriter_fourcc(*'mp4v'),
    fps,
    (w, h)
)

results_log = []
frame_id = 0

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    detections = yolo_model(frame, conf=0.4)[0]

    for box in detections.boxes:
        x1, y1, x2, y2 = map(int, box.xyxy[0])
        crop = frame[y1:y2, x1:x2]

        raw_text = "UNREADABLE"
        final_plate = "UNREADABLE"

        if crop.size != 0:
            ocr_res = ocr.ocr(crop, cls=True)
            if ocr_res and ocr_res[0]:
                raw_text = "".join([l[1][0] for l in ocr_res[0]])
                plate = smart_post(raw_text)
                final_plate = smart_post(raw_text)
                # final_plate = raw_text if raw_text else "NO_TEXT"


        color = (0,255,0) if final_plate not in ["INVALID","UNREADABLE"] else (0,0,255)

        cv2.rectangle(frame, (x1,y1), (x2,y2), color, 2)
        # cv2.putText(frame, final_plate, (x1,y1-10),
        #             cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
        cv2.putText(
    frame,
    raw_text if raw_text else "NO_TEXT",
    (x1, y1 - 10),
    cv2.FONT_HERSHEY_SIMPLEX,
    0.7,
    (255, 255, 0),
    2
)


        results_log.append([
            frame_id, x1, y1, x2, y2, raw_text, final_plate
        ])
        # Save evidence frame ONLY for valid plates
        if final_plate not in ["UNREADABLE"]:

          frame_filename = f"frame_{frame_id}_{final_plate}.jpg"
          frame_path = os.path.join(FRAME_SAVE_DIR, frame_filename)
          cv2.imwrite(frame_path, frame)
          saved_plates.add(final_plate)


    out.write(frame)
    frame_id += 1

cap.release()
out.release()



with open(OUTPUT_CSV, "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerow(["frame", "x1", "y1", "x2", "y2", "raw_ocr", "final_plate"])
    writer.writerows(results_log)

print("Saved:", OUTPUT_VIDEO)
print("Saved:", OUTPUT_CSV)

# files.download(OUTPUT_VIDEO)
# files.download(OUTPUT_CSV)

import pandas as pd

df = pd.DataFrame(
    results_log,
    columns=["frame", "x1", "y1", "x2", "y2", "raw_ocr", "plate"]
)

# Remove invalid / unreadable plates
valid_df = df[~df["plate"].isin(["INVALID", "UNREADABLE"])]

# Get unique plates (first occurrence)
unique_df = (
    valid_df
    .drop_duplicates(subset=["plate"])
    .reset_index(drop=True)
)

# Save CSVs
df.to_csv("anpr_framewise (10).csv", index=False)
unique_df.to_csv("anpr_unique_plates (10).csv", index=False)

print("Saved:")
print("- anpr_framewise.csv (frame-wise detections)")
print("- anpr_unique_plates.csv (unique plate list)")

!zip -r detected_frames.zip /content/detected_frames

import shutil
import os

FOLDER_PATH = "/content/detected_frames"

# Delete folder if it exists
if os.path.exists(FOLDER_PATH):
    shutil.rmtree(FOLDER_PATH)

# Recreate empty folder
os.makedirs(FOLDER_PATH)

print("Folder reset:", FOLDER_PATH)

